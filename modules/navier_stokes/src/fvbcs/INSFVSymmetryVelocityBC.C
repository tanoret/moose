//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "INSFVSymmetryVelocityBC.h"

registerMooseObject("NavierStokesApp", INSFVSymmetryVelocityBC);

InputParameters
INSFVSymmetryVelocityBC::validParams()
{
  InputParameters params = INSFVSymmetryBC::validParams();
  params += INSFVMomentumResidualObject::validParams();
  params.addClassDescription(
      "Implements a free slip boundary condition using a penalty formulation.");
  params.addRequiredParam<MooseFunctorName>("u", "The velocity in the x direction.");
  params.addParam<MooseFunctorName>("v", 0, "The velocity in the y direction.");
  params.addParam<MooseFunctorName>("w", 0, "The velocity in the z direction.");
  params.addRequiredParam<MaterialPropertyName>("mu", "The viscosity");
  return params;
}

INSFVSymmetryVelocityBC::INSFVSymmetryVelocityBC(const InputParameters & params)
  : INSFVSymmetryBC(params),
    INSFVMomentumResidualObject(*this),
    _u_functor(getFunctor<ADReal>("u")),
    _v_functor(getFunctor<ADReal>("v")),
    _w_functor(getFunctor<ADReal>("w")),
    _mu(getFunctor<ADReal>("mu")),
    _dim(_subproblem.mesh().dimension()),
    _computing_rc_data(false)
{
#ifndef MOOSE_GLOBAL_AD_INDEXING
  mooseError("INSFV is not supported by local AD indexing. In order to use INSFV, please run the "
             "configure script in the root MOOSE directory with the configure option "
             "'--with-ad-indexing-type=global'");
#endif
}

ADReal
INSFVSymmetryVelocityBC::computeQpResidual()
{
  const bool use_elem = _face_info->faceType(_var.name()) == FaceInfo::VarFaceNeighbors::ELEM;
  const auto normal = use_elem ? _face_info->normal() : Point(-_face_info->normal());
  const auto sub_id =
      use_elem ? _face_info->elem().subdomain_id() : _face_info->neighbor().subdomain_id();
  const Point & cell_centroid =
      use_elem ? _face_info->elemCentroid() : _face_info->neighborCentroid();
  const auto u_C =
      use_elem ? _u_functor(&_face_info->elem()) : _u_functor(_face_info->neighborPtr());
  const auto v_C =
      use_elem ? _v_functor(&_face_info->elem()) : _v_functor(_face_info->neighborPtr());
  const auto w_C =
      use_elem ? _w_functor(&_face_info->elem()) : _w_functor(_face_info->neighborPtr());

  const auto d_perpendicular = std::abs((_face_info->faceCentroid() - cell_centroid) * normal);

  // See Moukalled 15.150. Recall that we multiply by the area in the base class, so S_b ->
  // normal.norm() -> 1 here.

  const auto face =
      std::make_tuple(_face_info, Moose::FV::LimiterType::CentralDifference, true, sub_id);

  const auto mu_b = _mu(face);

  ADReal v_dot_n = u_C * normal(0);
  if (_dim > 1)
    v_dot_n += v_C * normal(1);
  if (_dim > 2)
    v_dot_n += w_C * normal(2);

  if (_computing_rc_data)
    _a = normal(_index) * mu_b / d_perpendicular * normal(_index);

  return mu_b / d_perpendicular * v_dot_n * normal(_index);
}

void
INSFVSymmetryVelocityBC::gatherRCData(const FaceInfo & fi)
{
  _face_info = &fi;
  _face_type = fi.faceType(_var.name());

  _computing_rc_data = true;
  // Fill-in the coefficient _a (but without multiplication by A)
  computeQpResidual();
  _computing_rc_data = false;

  _rc_uo.addToA((_face_type == FaceInfo::VarFaceNeighbors::ELEM) ? &fi.elem() : fi.neighborPtr(),
                _index,
                _a * (fi.faceArea() * fi.faceCoord()));
}
