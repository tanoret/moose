# MOOSE Newsletter (May 2023)

## Framework Improvements

### Positions system

A new system was implemented in MOOSE. [Positions](syntax/Positions/index.md) are used to keep track
of the locations of objects during MOOSE-based simulations.
By default, they are updated when the mesh changes and on every execution. They can be used to spawn
`MultiApps` distributed at the positions stored in the `Positions` object.
Several `Positions` were implemented to help kickstart the use of the new system:

- [InputPositions.md]
- [FilePositions.md]
- [ReporterPositions.md]
- [MultiAppPositions.md]
- [ElementCentroidPositions.md]
- [ElementGroupCentroidPositions.md]

Positions can now also be used to match source and target locations during transfers.
By specifying the [!param](/Transfers/MultiAppGeneralFieldNearestNodeTransfer/use_nearest_positions),
target locations in the target application will only be matched with source locations that
are nearest to the same `Position` than any of the other `Position` in the `Positions` object.

### Possibility to combine TimeSteppers

The time stepper system in MOOSE has been improved. A new [`[TimeSteppers]`](TimeSteppers/index.md) block has been introduced to replace the functionality of the current `[TimeStepper]` block. The new system keeps the features of `[TimeStepper]` and also supports composing multiple time steppers to compute the time step size. Users can still use `[TimeStepper]` for now, but in the future this block will be deprecated.

When more than one time stepper is provided, the new time stepper system will automatically compute the minimum time step among all the input time steppers as the time step size to use for that application. The new time stepper system also provides a [!param](/Executioner/TimeSteppers/lower_bound) parameter to further control the time stepper size (e.g. enable growth driven by a single time stepper). This system is controllable via the [Controls](syntax/Controls/index.md) system. The user can turn on/off the provided time steppers to control the usage of time steppers ; for example, one could make time stepper(s) only active [during a certain time period](TimePeriod.md).

## Modules improvements

### Fluid properties for the NaK eutectic

Fluid properties were added for the `NaK` eutectic in the fluid properties module.
These are extracted from the public Sodium handbook chapter on fluid properties \cite().
The fluid properties implemented should suffice for use with the Navier Stokes module.

### Functor solid thermal properties

A functor version of the solid thermal properties material has been added to the solid properties module.
Functor materials are more flexible, enabling all types of arbitrary evaluations on faces or points with an element for example.
This addition is leveraged by the finite volume heat conduction solver.

## Bug Fixes and Minor Enhancements

- Moving source points in Dirac Kernels, such as the [ReporterPointSource.md] are now supported.
- A [ParsedVectorAux.md] has been added to MOOSE. It enables forming in a very
  flexible manner vector auxiliary variables. It can be used for initialization
  of these variables, a long standing limitation of using vector variables.
- Added error checking for calling variable APIs that would result in use of
  `Assembly` neighbor AD data which has not been implemented. Consequently the
  neighbor test gradient in `ADInterfaceKernel` no longer pretends to have
  derivative data.
- Advection schemes other than `upwind` and `average` can now be used in
  `FVAdvection`, e.g. TVD schemes such as `min_mod` and `vanLeer`. This is
  useful for users who want to model scalar advection in a constant background
  velocity field.
- Dirichlet finite volume boundary conditions can now be controlled using the
  [Controls](syntax/Controls/index.md) system.
- We now always use undisplaced neighbor reference points when reinitializing
  displaced mesh neighbor finite element data. This is both an optimization and
  a bug fix for contexts like cohesive zones in which attempting to invert the
  physical points from the element side into reference points on the neighbor side would
  fail because the element and neighbor sides are no longer coincident.

### Always ensure the mesh is prepared for use

Systems like finite volume rely on links being formed between elements and their
neighbors. Modules like `thermal_hydraulics`  rely on knowing the correct spatial dimension of a
mesh if a mesh has been rotated or translated in space. This kind of data relies
on the libMesh mesh being properly prepared for use. Prior to this month, it was
possible for a simulation to begin without the mesh being prepared, resulting in
anything from segmentation faults to poor solution convergence to weird
results. This buggy behavior has been fixed by going through a lot of mesh
generators which don't prepared the mesh and adding lines like
`mesh->set_isnt_prepared()`. This fix should "silently" benefit all users.

### Add capability to abort nonlinear/linear solves early using the Terminator

Using an [!param](/UserObjects/Terminator/execute_on) of `LINEAR` or `NONLINEAR`, the
`Terminator` can now cut short almost immediately a solve, in order to cut the iterative solve
and try again with a smaller time step.

### Added function average post-processors

The post-processors [FunctionElementAverage.md] and [FunctionSideAverage.md]
were added, which compute the average of a function over blocks and boundaries,
respectively.
